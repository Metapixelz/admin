// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/bo-mathadventure/admin/ent/announcement"
	"github.com/bo-mathadventure/admin/ent/ban"
	"github.com/bo-mathadventure/admin/ent/maps"
	"github.com/bo-mathadventure/admin/ent/predicate"
	"github.com/bo-mathadventure/admin/ent/report"
	"github.com/bo-mathadventure/admin/ent/textures"
	"github.com/bo-mathadventure/admin/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnnouncement = "Announcement"
	TypeBan          = "Ban"
	TypeMaps         = "Maps"
	TypeReport       = "Report"
	TypeTextures     = "Textures"
	TypeUser         = "User"
)

// AnnouncementMutation represents an operation that mutates the Announcement nodes in the graph.
type AnnouncementMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *string
	message       *string
	createdAt     *time.Time
	validUntil    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Announcement, error)
	predicates    []predicate.Announcement
}

var _ ent.Mutation = (*AnnouncementMutation)(nil)

// announcementOption allows management of the mutation configuration using functional options.
type announcementOption func(*AnnouncementMutation)

// newAnnouncementMutation creates new mutation for the Announcement entity.
func newAnnouncementMutation(c config, op Op, opts ...announcementOption) *AnnouncementMutation {
	m := &AnnouncementMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnouncement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnouncementID sets the ID field of the mutation.
func withAnnouncementID(id int) announcementOption {
	return func(m *AnnouncementMutation) {
		var (
			err   error
			once  sync.Once
			value *Announcement
		)
		m.oldValue = func(ctx context.Context) (*Announcement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Announcement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnouncement sets the old Announcement of the mutation.
func withAnnouncement(node *Announcement) announcementOption {
	return func(m *AnnouncementMutation) {
		m.oldValue = func(context.Context) (*Announcement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnouncementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnouncementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnouncementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnouncementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Announcement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *AnnouncementMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AnnouncementMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AnnouncementMutation) ResetType() {
	m._type = nil
}

// SetMessage sets the "message" field.
func (m *AnnouncementMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *AnnouncementMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AnnouncementMutation) ResetMessage() {
	m.message = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *AnnouncementMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *AnnouncementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *AnnouncementMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetValidUntil sets the "validUntil" field.
func (m *AnnouncementMutation) SetValidUntil(t time.Time) {
	m.validUntil = &t
}

// ValidUntil returns the value of the "validUntil" field in the mutation.
func (m *AnnouncementMutation) ValidUntil() (r time.Time, exists bool) {
	v := m.validUntil
	if v == nil {
		return
	}
	return *v, true
}

// OldValidUntil returns the old "validUntil" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldValidUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidUntil: %w", err)
	}
	return oldValue.ValidUntil, nil
}

// ClearValidUntil clears the value of the "validUntil" field.
func (m *AnnouncementMutation) ClearValidUntil() {
	m.validUntil = nil
	m.clearedFields[announcement.FieldValidUntil] = struct{}{}
}

// ValidUntilCleared returns if the "validUntil" field was cleared in this mutation.
func (m *AnnouncementMutation) ValidUntilCleared() bool {
	_, ok := m.clearedFields[announcement.FieldValidUntil]
	return ok
}

// ResetValidUntil resets all changes to the "validUntil" field.
func (m *AnnouncementMutation) ResetValidUntil() {
	m.validUntil = nil
	delete(m.clearedFields, announcement.FieldValidUntil)
}

// Where appends a list predicates to the AnnouncementMutation builder.
func (m *AnnouncementMutation) Where(ps ...predicate.Announcement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnnouncementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnnouncementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Announcement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnnouncementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnnouncementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Announcement).
func (m *AnnouncementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnouncementMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, announcement.FieldType)
	}
	if m.message != nil {
		fields = append(fields, announcement.FieldMessage)
	}
	if m.createdAt != nil {
		fields = append(fields, announcement.FieldCreatedAt)
	}
	if m.validUntil != nil {
		fields = append(fields, announcement.FieldValidUntil)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnouncementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case announcement.FieldType:
		return m.GetType()
	case announcement.FieldMessage:
		return m.Message()
	case announcement.FieldCreatedAt:
		return m.CreatedAt()
	case announcement.FieldValidUntil:
		return m.ValidUntil()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnouncementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case announcement.FieldType:
		return m.OldType(ctx)
	case announcement.FieldMessage:
		return m.OldMessage(ctx)
	case announcement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case announcement.FieldValidUntil:
		return m.OldValidUntil(ctx)
	}
	return nil, fmt.Errorf("unknown Announcement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case announcement.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case announcement.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case announcement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case announcement.FieldValidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidUntil(v)
		return nil
	}
	return fmt.Errorf("unknown Announcement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnouncementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnouncementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Announcement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnouncementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(announcement.FieldValidUntil) {
		fields = append(fields, announcement.FieldValidUntil)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnouncementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnouncementMutation) ClearField(name string) error {
	switch name {
	case announcement.FieldValidUntil:
		m.ClearValidUntil()
		return nil
	}
	return fmt.Errorf("unknown Announcement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnouncementMutation) ResetField(name string) error {
	switch name {
	case announcement.FieldType:
		m.ResetType()
		return nil
	case announcement.FieldMessage:
		m.ResetMessage()
		return nil
	case announcement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case announcement.FieldValidUntil:
		m.ResetValidUntil()
		return nil
	}
	return fmt.Errorf("unknown Announcement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnouncementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnouncementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnouncementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnouncementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnouncementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnouncementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnouncementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Announcement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnouncementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Announcement edge %s", name)
}

// BanMutation represents an operation that mutates the Ban nodes in the graph.
type BanMutation struct {
	config
	op            Op
	typ           string
	id            *int
	check         *string
	message       *string
	validUntil    *time.Time
	createdAt     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Ban, error)
	predicates    []predicate.Ban
}

var _ ent.Mutation = (*BanMutation)(nil)

// banOption allows management of the mutation configuration using functional options.
type banOption func(*BanMutation)

// newBanMutation creates new mutation for the Ban entity.
func newBanMutation(c config, op Op, opts ...banOption) *BanMutation {
	m := &BanMutation{
		config:        c,
		op:            op,
		typ:           TypeBan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanID sets the ID field of the mutation.
func withBanID(id int) banOption {
	return func(m *BanMutation) {
		var (
			err   error
			once  sync.Once
			value *Ban
		)
		m.oldValue = func(ctx context.Context) (*Ban, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ban.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBan sets the old Ban of the mutation.
func withBan(node *Ban) banOption {
	return func(m *BanMutation) {
		m.oldValue = func(context.Context) (*Ban, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ban.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCheck sets the "check" field.
func (m *BanMutation) SetCheck(s string) {
	m.check = &s
}

// Check returns the value of the "check" field in the mutation.
func (m *BanMutation) Check() (r string, exists bool) {
	v := m.check
	if v == nil {
		return
	}
	return *v, true
}

// OldCheck returns the old "check" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldCheck(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheck: %w", err)
	}
	return oldValue.Check, nil
}

// ResetCheck resets all changes to the "check" field.
func (m *BanMutation) ResetCheck() {
	m.check = nil
}

// SetMessage sets the "message" field.
func (m *BanMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BanMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BanMutation) ResetMessage() {
	m.message = nil
}

// SetValidUntil sets the "validUntil" field.
func (m *BanMutation) SetValidUntil(t time.Time) {
	m.validUntil = &t
}

// ValidUntil returns the value of the "validUntil" field in the mutation.
func (m *BanMutation) ValidUntil() (r time.Time, exists bool) {
	v := m.validUntil
	if v == nil {
		return
	}
	return *v, true
}

// OldValidUntil returns the old "validUntil" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldValidUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidUntil: %w", err)
	}
	return oldValue.ValidUntil, nil
}

// ResetValidUntil resets all changes to the "validUntil" field.
func (m *BanMutation) ResetValidUntil() {
	m.validUntil = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *BanMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *BanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Ban entity.
// If the Ban object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *BanMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// Where appends a list predicates to the BanMutation builder.
func (m *BanMutation) Where(ps ...predicate.Ban) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ban, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ban).
func (m *BanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.check != nil {
		fields = append(fields, ban.FieldCheck)
	}
	if m.message != nil {
		fields = append(fields, ban.FieldMessage)
	}
	if m.validUntil != nil {
		fields = append(fields, ban.FieldValidUntil)
	}
	if m.createdAt != nil {
		fields = append(fields, ban.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ban.FieldCheck:
		return m.Check()
	case ban.FieldMessage:
		return m.Message()
	case ban.FieldValidUntil:
		return m.ValidUntil()
	case ban.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ban.FieldCheck:
		return m.OldCheck(ctx)
	case ban.FieldMessage:
		return m.OldMessage(ctx)
	case ban.FieldValidUntil:
		return m.OldValidUntil(ctx)
	case ban.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ban field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ban.FieldCheck:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheck(v)
		return nil
	case ban.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case ban.FieldValidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidUntil(v)
		return nil
	case ban.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ban field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ban numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ban nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanMutation) ResetField(name string) error {
	switch name {
	case ban.FieldCheck:
		m.ResetCheck()
		return nil
	case ban.FieldMessage:
		m.ResetMessage()
		return nil
	case ban.FieldValidUntil:
		m.ResetValidUntil()
		return nil
	case ban.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ban field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ban unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ban edge %s", name)
}

// MapsMutation represents an operation that mutates the Maps nodes in the graph.
type MapsMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	roomName                   *string
	mapUrl                     *string
	policyNumber               *int
	addpolicyNumber            *int
	contactPage                *string
	tags                       *[]string
	appendtags                 []string
	enableChat                 *bool
	enableChatUpload           *bool
	enableChatOnlineList       *bool
	enableChatDisconnectedList *bool
	canReport                  *bool
	expireOn                   *time.Time
	createdAt                  *time.Time
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Maps, error)
	predicates                 []predicate.Maps
}

var _ ent.Mutation = (*MapsMutation)(nil)

// mapsOption allows management of the mutation configuration using functional options.
type mapsOption func(*MapsMutation)

// newMapsMutation creates new mutation for the Maps entity.
func newMapsMutation(c config, op Op, opts ...mapsOption) *MapsMutation {
	m := &MapsMutation{
		config:        c,
		op:            op,
		typ:           TypeMaps,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMapsID sets the ID field of the mutation.
func withMapsID(id int) mapsOption {
	return func(m *MapsMutation) {
		var (
			err   error
			once  sync.Once
			value *Maps
		)
		m.oldValue = func(ctx context.Context) (*Maps, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Maps.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaps sets the old Maps of the mutation.
func withMaps(node *Maps) mapsOption {
	return func(m *MapsMutation) {
		m.oldValue = func(context.Context) (*Maps, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MapsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MapsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MapsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MapsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Maps.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoomName sets the "roomName" field.
func (m *MapsMutation) SetRoomName(s string) {
	m.roomName = &s
}

// RoomName returns the value of the "roomName" field in the mutation.
func (m *MapsMutation) RoomName() (r string, exists bool) {
	v := m.roomName
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomName returns the old "roomName" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldRoomName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomName: %w", err)
	}
	return oldValue.RoomName, nil
}

// ResetRoomName resets all changes to the "roomName" field.
func (m *MapsMutation) ResetRoomName() {
	m.roomName = nil
}

// SetMapUrl sets the "mapUrl" field.
func (m *MapsMutation) SetMapUrl(s string) {
	m.mapUrl = &s
}

// MapUrl returns the value of the "mapUrl" field in the mutation.
func (m *MapsMutation) MapUrl() (r string, exists bool) {
	v := m.mapUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldMapUrl returns the old "mapUrl" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldMapUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMapUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMapUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMapUrl: %w", err)
	}
	return oldValue.MapUrl, nil
}

// ResetMapUrl resets all changes to the "mapUrl" field.
func (m *MapsMutation) ResetMapUrl() {
	m.mapUrl = nil
}

// SetPolicyNumber sets the "policyNumber" field.
func (m *MapsMutation) SetPolicyNumber(i int) {
	m.policyNumber = &i
	m.addpolicyNumber = nil
}

// PolicyNumber returns the value of the "policyNumber" field in the mutation.
func (m *MapsMutation) PolicyNumber() (r int, exists bool) {
	v := m.policyNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyNumber returns the old "policyNumber" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldPolicyNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyNumber: %w", err)
	}
	return oldValue.PolicyNumber, nil
}

// AddPolicyNumber adds i to the "policyNumber" field.
func (m *MapsMutation) AddPolicyNumber(i int) {
	if m.addpolicyNumber != nil {
		*m.addpolicyNumber += i
	} else {
		m.addpolicyNumber = &i
	}
}

// AddedPolicyNumber returns the value that was added to the "policyNumber" field in this mutation.
func (m *MapsMutation) AddedPolicyNumber() (r int, exists bool) {
	v := m.addpolicyNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetPolicyNumber resets all changes to the "policyNumber" field.
func (m *MapsMutation) ResetPolicyNumber() {
	m.policyNumber = nil
	m.addpolicyNumber = nil
}

// SetContactPage sets the "contactPage" field.
func (m *MapsMutation) SetContactPage(s string) {
	m.contactPage = &s
}

// ContactPage returns the value of the "contactPage" field in the mutation.
func (m *MapsMutation) ContactPage() (r string, exists bool) {
	v := m.contactPage
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPage returns the old "contactPage" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldContactPage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPage: %w", err)
	}
	return oldValue.ContactPage, nil
}

// ResetContactPage resets all changes to the "contactPage" field.
func (m *MapsMutation) ResetContactPage() {
	m.contactPage = nil
}

// SetTags sets the "tags" field.
func (m *MapsMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *MapsMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *MapsMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *MapsMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *MapsMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetEnableChat sets the "enableChat" field.
func (m *MapsMutation) SetEnableChat(b bool) {
	m.enableChat = &b
}

// EnableChat returns the value of the "enableChat" field in the mutation.
func (m *MapsMutation) EnableChat() (r bool, exists bool) {
	v := m.enableChat
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableChat returns the old "enableChat" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldEnableChat(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableChat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableChat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableChat: %w", err)
	}
	return oldValue.EnableChat, nil
}

// ResetEnableChat resets all changes to the "enableChat" field.
func (m *MapsMutation) ResetEnableChat() {
	m.enableChat = nil
}

// SetEnableChatUpload sets the "enableChatUpload" field.
func (m *MapsMutation) SetEnableChatUpload(b bool) {
	m.enableChatUpload = &b
}

// EnableChatUpload returns the value of the "enableChatUpload" field in the mutation.
func (m *MapsMutation) EnableChatUpload() (r bool, exists bool) {
	v := m.enableChatUpload
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableChatUpload returns the old "enableChatUpload" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldEnableChatUpload(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableChatUpload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableChatUpload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableChatUpload: %w", err)
	}
	return oldValue.EnableChatUpload, nil
}

// ResetEnableChatUpload resets all changes to the "enableChatUpload" field.
func (m *MapsMutation) ResetEnableChatUpload() {
	m.enableChatUpload = nil
}

// SetEnableChatOnlineList sets the "enableChatOnlineList" field.
func (m *MapsMutation) SetEnableChatOnlineList(b bool) {
	m.enableChatOnlineList = &b
}

// EnableChatOnlineList returns the value of the "enableChatOnlineList" field in the mutation.
func (m *MapsMutation) EnableChatOnlineList() (r bool, exists bool) {
	v := m.enableChatOnlineList
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableChatOnlineList returns the old "enableChatOnlineList" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldEnableChatOnlineList(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableChatOnlineList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableChatOnlineList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableChatOnlineList: %w", err)
	}
	return oldValue.EnableChatOnlineList, nil
}

// ResetEnableChatOnlineList resets all changes to the "enableChatOnlineList" field.
func (m *MapsMutation) ResetEnableChatOnlineList() {
	m.enableChatOnlineList = nil
}

// SetEnableChatDisconnectedList sets the "enableChatDisconnectedList" field.
func (m *MapsMutation) SetEnableChatDisconnectedList(b bool) {
	m.enableChatDisconnectedList = &b
}

// EnableChatDisconnectedList returns the value of the "enableChatDisconnectedList" field in the mutation.
func (m *MapsMutation) EnableChatDisconnectedList() (r bool, exists bool) {
	v := m.enableChatDisconnectedList
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableChatDisconnectedList returns the old "enableChatDisconnectedList" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldEnableChatDisconnectedList(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableChatDisconnectedList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableChatDisconnectedList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableChatDisconnectedList: %w", err)
	}
	return oldValue.EnableChatDisconnectedList, nil
}

// ResetEnableChatDisconnectedList resets all changes to the "enableChatDisconnectedList" field.
func (m *MapsMutation) ResetEnableChatDisconnectedList() {
	m.enableChatDisconnectedList = nil
}

// SetCanReport sets the "canReport" field.
func (m *MapsMutation) SetCanReport(b bool) {
	m.canReport = &b
}

// CanReport returns the value of the "canReport" field in the mutation.
func (m *MapsMutation) CanReport() (r bool, exists bool) {
	v := m.canReport
	if v == nil {
		return
	}
	return *v, true
}

// OldCanReport returns the old "canReport" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldCanReport(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanReport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanReport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanReport: %w", err)
	}
	return oldValue.CanReport, nil
}

// ResetCanReport resets all changes to the "canReport" field.
func (m *MapsMutation) ResetCanReport() {
	m.canReport = nil
}

// SetExpireOn sets the "expireOn" field.
func (m *MapsMutation) SetExpireOn(t time.Time) {
	m.expireOn = &t
}

// ExpireOn returns the value of the "expireOn" field in the mutation.
func (m *MapsMutation) ExpireOn() (r time.Time, exists bool) {
	v := m.expireOn
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireOn returns the old "expireOn" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldExpireOn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireOn: %w", err)
	}
	return oldValue.ExpireOn, nil
}

// ClearExpireOn clears the value of the "expireOn" field.
func (m *MapsMutation) ClearExpireOn() {
	m.expireOn = nil
	m.clearedFields[maps.FieldExpireOn] = struct{}{}
}

// ExpireOnCleared returns if the "expireOn" field was cleared in this mutation.
func (m *MapsMutation) ExpireOnCleared() bool {
	_, ok := m.clearedFields[maps.FieldExpireOn]
	return ok
}

// ResetExpireOn resets all changes to the "expireOn" field.
func (m *MapsMutation) ResetExpireOn() {
	m.expireOn = nil
	delete(m.clearedFields, maps.FieldExpireOn)
}

// SetCreatedAt sets the "createdAt" field.
func (m *MapsMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *MapsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Maps entity.
// If the Maps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MapsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *MapsMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// Where appends a list predicates to the MapsMutation builder.
func (m *MapsMutation) Where(ps ...predicate.Maps) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MapsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MapsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Maps, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MapsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MapsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Maps).
func (m *MapsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MapsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.roomName != nil {
		fields = append(fields, maps.FieldRoomName)
	}
	if m.mapUrl != nil {
		fields = append(fields, maps.FieldMapUrl)
	}
	if m.policyNumber != nil {
		fields = append(fields, maps.FieldPolicyNumber)
	}
	if m.contactPage != nil {
		fields = append(fields, maps.FieldContactPage)
	}
	if m.tags != nil {
		fields = append(fields, maps.FieldTags)
	}
	if m.enableChat != nil {
		fields = append(fields, maps.FieldEnableChat)
	}
	if m.enableChatUpload != nil {
		fields = append(fields, maps.FieldEnableChatUpload)
	}
	if m.enableChatOnlineList != nil {
		fields = append(fields, maps.FieldEnableChatOnlineList)
	}
	if m.enableChatDisconnectedList != nil {
		fields = append(fields, maps.FieldEnableChatDisconnectedList)
	}
	if m.canReport != nil {
		fields = append(fields, maps.FieldCanReport)
	}
	if m.expireOn != nil {
		fields = append(fields, maps.FieldExpireOn)
	}
	if m.createdAt != nil {
		fields = append(fields, maps.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MapsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case maps.FieldRoomName:
		return m.RoomName()
	case maps.FieldMapUrl:
		return m.MapUrl()
	case maps.FieldPolicyNumber:
		return m.PolicyNumber()
	case maps.FieldContactPage:
		return m.ContactPage()
	case maps.FieldTags:
		return m.Tags()
	case maps.FieldEnableChat:
		return m.EnableChat()
	case maps.FieldEnableChatUpload:
		return m.EnableChatUpload()
	case maps.FieldEnableChatOnlineList:
		return m.EnableChatOnlineList()
	case maps.FieldEnableChatDisconnectedList:
		return m.EnableChatDisconnectedList()
	case maps.FieldCanReport:
		return m.CanReport()
	case maps.FieldExpireOn:
		return m.ExpireOn()
	case maps.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MapsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case maps.FieldRoomName:
		return m.OldRoomName(ctx)
	case maps.FieldMapUrl:
		return m.OldMapUrl(ctx)
	case maps.FieldPolicyNumber:
		return m.OldPolicyNumber(ctx)
	case maps.FieldContactPage:
		return m.OldContactPage(ctx)
	case maps.FieldTags:
		return m.OldTags(ctx)
	case maps.FieldEnableChat:
		return m.OldEnableChat(ctx)
	case maps.FieldEnableChatUpload:
		return m.OldEnableChatUpload(ctx)
	case maps.FieldEnableChatOnlineList:
		return m.OldEnableChatOnlineList(ctx)
	case maps.FieldEnableChatDisconnectedList:
		return m.OldEnableChatDisconnectedList(ctx)
	case maps.FieldCanReport:
		return m.OldCanReport(ctx)
	case maps.FieldExpireOn:
		return m.OldExpireOn(ctx)
	case maps.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Maps field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MapsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case maps.FieldRoomName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomName(v)
		return nil
	case maps.FieldMapUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMapUrl(v)
		return nil
	case maps.FieldPolicyNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyNumber(v)
		return nil
	case maps.FieldContactPage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPage(v)
		return nil
	case maps.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case maps.FieldEnableChat:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableChat(v)
		return nil
	case maps.FieldEnableChatUpload:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableChatUpload(v)
		return nil
	case maps.FieldEnableChatOnlineList:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableChatOnlineList(v)
		return nil
	case maps.FieldEnableChatDisconnectedList:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableChatDisconnectedList(v)
		return nil
	case maps.FieldCanReport:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanReport(v)
		return nil
	case maps.FieldExpireOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireOn(v)
		return nil
	case maps.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Maps field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MapsMutation) AddedFields() []string {
	var fields []string
	if m.addpolicyNumber != nil {
		fields = append(fields, maps.FieldPolicyNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MapsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case maps.FieldPolicyNumber:
		return m.AddedPolicyNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MapsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case maps.FieldPolicyNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPolicyNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Maps numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MapsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(maps.FieldExpireOn) {
		fields = append(fields, maps.FieldExpireOn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MapsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MapsMutation) ClearField(name string) error {
	switch name {
	case maps.FieldExpireOn:
		m.ClearExpireOn()
		return nil
	}
	return fmt.Errorf("unknown Maps nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MapsMutation) ResetField(name string) error {
	switch name {
	case maps.FieldRoomName:
		m.ResetRoomName()
		return nil
	case maps.FieldMapUrl:
		m.ResetMapUrl()
		return nil
	case maps.FieldPolicyNumber:
		m.ResetPolicyNumber()
		return nil
	case maps.FieldContactPage:
		m.ResetContactPage()
		return nil
	case maps.FieldTags:
		m.ResetTags()
		return nil
	case maps.FieldEnableChat:
		m.ResetEnableChat()
		return nil
	case maps.FieldEnableChatUpload:
		m.ResetEnableChatUpload()
		return nil
	case maps.FieldEnableChatOnlineList:
		m.ResetEnableChatOnlineList()
		return nil
	case maps.FieldEnableChatDisconnectedList:
		m.ResetEnableChatDisconnectedList()
		return nil
	case maps.FieldCanReport:
		m.ResetCanReport()
		return nil
	case maps.FieldExpireOn:
		m.ResetExpireOn()
		return nil
	case maps.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Maps field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MapsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MapsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MapsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MapsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MapsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MapsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MapsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Maps unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MapsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Maps edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	reportedUserComment *string
	roomUrl             *string
	hide                *bool
	createdAt           *time.Time
	clearedFields       map[string]struct{}
	reportedUser        *int
	clearedreportedUser bool
	reporterUser        *int
	clearedreporterUser bool
	done                bool
	oldValue            func(context.Context) (*Report, error)
	predicates          []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id int) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReportedUserComment sets the "reportedUserComment" field.
func (m *ReportMutation) SetReportedUserComment(s string) {
	m.reportedUserComment = &s
}

// ReportedUserComment returns the value of the "reportedUserComment" field in the mutation.
func (m *ReportMutation) ReportedUserComment() (r string, exists bool) {
	v := m.reportedUserComment
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedUserComment returns the old "reportedUserComment" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReportedUserComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportedUserComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportedUserComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedUserComment: %w", err)
	}
	return oldValue.ReportedUserComment, nil
}

// ResetReportedUserComment resets all changes to the "reportedUserComment" field.
func (m *ReportMutation) ResetReportedUserComment() {
	m.reportedUserComment = nil
}

// SetRoomUrl sets the "roomUrl" field.
func (m *ReportMutation) SetRoomUrl(s string) {
	m.roomUrl = &s
}

// RoomUrl returns the value of the "roomUrl" field in the mutation.
func (m *ReportMutation) RoomUrl() (r string, exists bool) {
	v := m.roomUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldRoomUrl returns the old "roomUrl" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldRoomUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoomUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoomUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoomUrl: %w", err)
	}
	return oldValue.RoomUrl, nil
}

// ResetRoomUrl resets all changes to the "roomUrl" field.
func (m *ReportMutation) ResetRoomUrl() {
	m.roomUrl = nil
}

// SetHide sets the "hide" field.
func (m *ReportMutation) SetHide(b bool) {
	m.hide = &b
}

// Hide returns the value of the "hide" field in the mutation.
func (m *ReportMutation) Hide() (r bool, exists bool) {
	v := m.hide
	if v == nil {
		return
	}
	return *v, true
}

// OldHide returns the old "hide" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldHide(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHide: %w", err)
	}
	return oldValue.Hide, nil
}

// ResetHide resets all changes to the "hide" field.
func (m *ReportMutation) ResetHide() {
	m.hide = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *ReportMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ReportMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetReportedUserID sets the "reportedUser" edge to the User entity by id.
func (m *ReportMutation) SetReportedUserID(id int) {
	m.reportedUser = &id
}

// ClearReportedUser clears the "reportedUser" edge to the User entity.
func (m *ReportMutation) ClearReportedUser() {
	m.clearedreportedUser = true
}

// ReportedUserCleared reports if the "reportedUser" edge to the User entity was cleared.
func (m *ReportMutation) ReportedUserCleared() bool {
	return m.clearedreportedUser
}

// ReportedUserID returns the "reportedUser" edge ID in the mutation.
func (m *ReportMutation) ReportedUserID() (id int, exists bool) {
	if m.reportedUser != nil {
		return *m.reportedUser, true
	}
	return
}

// ReportedUserIDs returns the "reportedUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportedUserID instead. It exists only for internal usage by the builders.
func (m *ReportMutation) ReportedUserIDs() (ids []int) {
	if id := m.reportedUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReportedUser resets all changes to the "reportedUser" edge.
func (m *ReportMutation) ResetReportedUser() {
	m.reportedUser = nil
	m.clearedreportedUser = false
}

// SetReporterUserID sets the "reporterUser" edge to the User entity by id.
func (m *ReportMutation) SetReporterUserID(id int) {
	m.reporterUser = &id
}

// ClearReporterUser clears the "reporterUser" edge to the User entity.
func (m *ReportMutation) ClearReporterUser() {
	m.clearedreporterUser = true
}

// ReporterUserCleared reports if the "reporterUser" edge to the User entity was cleared.
func (m *ReportMutation) ReporterUserCleared() bool {
	return m.clearedreporterUser
}

// ReporterUserID returns the "reporterUser" edge ID in the mutation.
func (m *ReportMutation) ReporterUserID() (id int, exists bool) {
	if m.reporterUser != nil {
		return *m.reporterUser, true
	}
	return
}

// ReporterUserIDs returns the "reporterUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReporterUserID instead. It exists only for internal usage by the builders.
func (m *ReportMutation) ReporterUserIDs() (ids []int) {
	if id := m.reporterUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReporterUser resets all changes to the "reporterUser" edge.
func (m *ReportMutation) ResetReporterUser() {
	m.reporterUser = nil
	m.clearedreporterUser = false
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Report, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.reportedUserComment != nil {
		fields = append(fields, report.FieldReportedUserComment)
	}
	if m.roomUrl != nil {
		fields = append(fields, report.FieldRoomUrl)
	}
	if m.hide != nil {
		fields = append(fields, report.FieldHide)
	}
	if m.createdAt != nil {
		fields = append(fields, report.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldReportedUserComment:
		return m.ReportedUserComment()
	case report.FieldRoomUrl:
		return m.RoomUrl()
	case report.FieldHide:
		return m.Hide()
	case report.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldReportedUserComment:
		return m.OldReportedUserComment(ctx)
	case report.FieldRoomUrl:
		return m.OldRoomUrl(ctx)
	case report.FieldHide:
		return m.OldHide(ctx)
	case report.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldReportedUserComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedUserComment(v)
		return nil
	case report.FieldRoomUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoomUrl(v)
		return nil
	case report.FieldHide:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHide(v)
		return nil
	case report.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldReportedUserComment:
		m.ResetReportedUserComment()
		return nil
	case report.FieldRoomUrl:
		m.ResetRoomUrl()
		return nil
	case report.FieldHide:
		m.ResetHide()
		return nil
	case report.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.reportedUser != nil {
		edges = append(edges, report.EdgeReportedUser)
	}
	if m.reporterUser != nil {
		edges = append(edges, report.EdgeReporterUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeReportedUser:
		if id := m.reportedUser; id != nil {
			return []ent.Value{*id}
		}
	case report.EdgeReporterUser:
		if id := m.reporterUser; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreportedUser {
		edges = append(edges, report.EdgeReportedUser)
	}
	if m.clearedreporterUser {
		edges = append(edges, report.EdgeReporterUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	switch name {
	case report.EdgeReportedUser:
		return m.clearedreportedUser
	case report.EdgeReporterUser:
		return m.clearedreporterUser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	switch name {
	case report.EdgeReportedUser:
		m.ClearReportedUser()
		return nil
	case report.EdgeReporterUser:
		m.ClearReporterUser()
		return nil
	}
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	switch name {
	case report.EdgeReportedUser:
		m.ResetReportedUser()
		return nil
	case report.EdgeReporterUser:
		m.ResetReporterUser()
		return nil
	}
	return fmt.Errorf("unknown Report edge %s", name)
}

// TexturesMutation represents an operation that mutates the Textures nodes in the graph.
type TexturesMutation struct {
	config
	op            Op
	typ           string
	id            *int
	texture       *string
	layer         *string
	url           *string
	tags          *[]string
	appendtags    []string
	createdAt     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Textures, error)
	predicates    []predicate.Textures
}

var _ ent.Mutation = (*TexturesMutation)(nil)

// texturesOption allows management of the mutation configuration using functional options.
type texturesOption func(*TexturesMutation)

// newTexturesMutation creates new mutation for the Textures entity.
func newTexturesMutation(c config, op Op, opts ...texturesOption) *TexturesMutation {
	m := &TexturesMutation{
		config:        c,
		op:            op,
		typ:           TypeTextures,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTexturesID sets the ID field of the mutation.
func withTexturesID(id int) texturesOption {
	return func(m *TexturesMutation) {
		var (
			err   error
			once  sync.Once
			value *Textures
		)
		m.oldValue = func(ctx context.Context) (*Textures, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Textures.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTextures sets the old Textures of the mutation.
func withTextures(node *Textures) texturesOption {
	return func(m *TexturesMutation) {
		m.oldValue = func(context.Context) (*Textures, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TexturesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TexturesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TexturesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TexturesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Textures.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTexture sets the "texture" field.
func (m *TexturesMutation) SetTexture(s string) {
	m.texture = &s
}

// Texture returns the value of the "texture" field in the mutation.
func (m *TexturesMutation) Texture() (r string, exists bool) {
	v := m.texture
	if v == nil {
		return
	}
	return *v, true
}

// OldTexture returns the old "texture" field's value of the Textures entity.
// If the Textures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TexturesMutation) OldTexture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTexture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTexture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTexture: %w", err)
	}
	return oldValue.Texture, nil
}

// ResetTexture resets all changes to the "texture" field.
func (m *TexturesMutation) ResetTexture() {
	m.texture = nil
}

// SetLayer sets the "layer" field.
func (m *TexturesMutation) SetLayer(s string) {
	m.layer = &s
}

// Layer returns the value of the "layer" field in the mutation.
func (m *TexturesMutation) Layer() (r string, exists bool) {
	v := m.layer
	if v == nil {
		return
	}
	return *v, true
}

// OldLayer returns the old "layer" field's value of the Textures entity.
// If the Textures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TexturesMutation) OldLayer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayer: %w", err)
	}
	return oldValue.Layer, nil
}

// ResetLayer resets all changes to the "layer" field.
func (m *TexturesMutation) ResetLayer() {
	m.layer = nil
}

// SetURL sets the "url" field.
func (m *TexturesMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *TexturesMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Textures entity.
// If the Textures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TexturesMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *TexturesMutation) ResetURL() {
	m.url = nil
}

// SetTags sets the "tags" field.
func (m *TexturesMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TexturesMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Textures entity.
// If the Textures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TexturesMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TexturesMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TexturesMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *TexturesMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *TexturesMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TexturesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Textures entity.
// If the Textures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TexturesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TexturesMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// Where appends a list predicates to the TexturesMutation builder.
func (m *TexturesMutation) Where(ps ...predicate.Textures) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TexturesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TexturesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Textures, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TexturesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TexturesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Textures).
func (m *TexturesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TexturesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.texture != nil {
		fields = append(fields, textures.FieldTexture)
	}
	if m.layer != nil {
		fields = append(fields, textures.FieldLayer)
	}
	if m.url != nil {
		fields = append(fields, textures.FieldURL)
	}
	if m.tags != nil {
		fields = append(fields, textures.FieldTags)
	}
	if m.createdAt != nil {
		fields = append(fields, textures.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TexturesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case textures.FieldTexture:
		return m.Texture()
	case textures.FieldLayer:
		return m.Layer()
	case textures.FieldURL:
		return m.URL()
	case textures.FieldTags:
		return m.Tags()
	case textures.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TexturesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case textures.FieldTexture:
		return m.OldTexture(ctx)
	case textures.FieldLayer:
		return m.OldLayer(ctx)
	case textures.FieldURL:
		return m.OldURL(ctx)
	case textures.FieldTags:
		return m.OldTags(ctx)
	case textures.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Textures field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TexturesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case textures.FieldTexture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTexture(v)
		return nil
	case textures.FieldLayer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayer(v)
		return nil
	case textures.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case textures.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case textures.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Textures field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TexturesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TexturesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TexturesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Textures numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TexturesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TexturesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TexturesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Textures nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TexturesMutation) ResetField(name string) error {
	switch name {
	case textures.FieldTexture:
		m.ResetTexture()
		return nil
	case textures.FieldLayer:
		m.ResetLayer()
		return nil
	case textures.FieldURL:
		m.ResetURL()
		return nil
	case textures.FieldTags:
		m.ResetTags()
		return nil
	case textures.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Textures field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TexturesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TexturesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TexturesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TexturesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TexturesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TexturesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TexturesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Textures unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TexturesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Textures edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	uuid              *string
	email             *string
	username          *string
	password          *string
	ssoIdentifier     *string
	vCardURL          *string
	permissions       *[]string
	appendpermissions []string
	tags              *[]string
	appendtags        []string
	lastLogin         *time.Time
	createdAt         *time.Time
	clearedFields     map[string]struct{}
	reported          map[int]struct{}
	removedreported   map[int]struct{}
	clearedreported   bool
	reporter          map[int]struct{}
	removedreporter   map[int]struct{}
	clearedreporter   bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetSsoIdentifier sets the "ssoIdentifier" field.
func (m *UserMutation) SetSsoIdentifier(s string) {
	m.ssoIdentifier = &s
}

// SsoIdentifier returns the value of the "ssoIdentifier" field in the mutation.
func (m *UserMutation) SsoIdentifier() (r string, exists bool) {
	v := m.ssoIdentifier
	if v == nil {
		return
	}
	return *v, true
}

// OldSsoIdentifier returns the old "ssoIdentifier" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSsoIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSsoIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSsoIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSsoIdentifier: %w", err)
	}
	return oldValue.SsoIdentifier, nil
}

// ClearSsoIdentifier clears the value of the "ssoIdentifier" field.
func (m *UserMutation) ClearSsoIdentifier() {
	m.ssoIdentifier = nil
	m.clearedFields[user.FieldSsoIdentifier] = struct{}{}
}

// SsoIdentifierCleared returns if the "ssoIdentifier" field was cleared in this mutation.
func (m *UserMutation) SsoIdentifierCleared() bool {
	_, ok := m.clearedFields[user.FieldSsoIdentifier]
	return ok
}

// ResetSsoIdentifier resets all changes to the "ssoIdentifier" field.
func (m *UserMutation) ResetSsoIdentifier() {
	m.ssoIdentifier = nil
	delete(m.clearedFields, user.FieldSsoIdentifier)
}

// SetVCardURL sets the "vCardURL" field.
func (m *UserMutation) SetVCardURL(s string) {
	m.vCardURL = &s
}

// VCardURL returns the value of the "vCardURL" field in the mutation.
func (m *UserMutation) VCardURL() (r string, exists bool) {
	v := m.vCardURL
	if v == nil {
		return
	}
	return *v, true
}

// OldVCardURL returns the old "vCardURL" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVCardURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVCardURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVCardURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVCardURL: %w", err)
	}
	return oldValue.VCardURL, nil
}

// ClearVCardURL clears the value of the "vCardURL" field.
func (m *UserMutation) ClearVCardURL() {
	m.vCardURL = nil
	m.clearedFields[user.FieldVCardURL] = struct{}{}
}

// VCardURLCleared returns if the "vCardURL" field was cleared in this mutation.
func (m *UserMutation) VCardURLCleared() bool {
	_, ok := m.clearedFields[user.FieldVCardURL]
	return ok
}

// ResetVCardURL resets all changes to the "vCardURL" field.
func (m *UserMutation) ResetVCardURL() {
	m.vCardURL = nil
	delete(m.clearedFields, user.FieldVCardURL)
}

// SetPermissions sets the "permissions" field.
func (m *UserMutation) SetPermissions(s []string) {
	m.permissions = &s
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserMutation) Permissions() (r []string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds s to the "permissions" field.
func (m *UserMutation) AppendPermissions(s []string) {
	m.appendpermissions = append(m.appendpermissions, s...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *UserMutation) AppendedPermissions() ([]string, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
}

// SetTags sets the "tags" field.
func (m *UserMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *UserMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *UserMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *UserMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *UserMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetLastLogin sets the "lastLogin" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.lastLogin = &t
}

// LastLogin returns the value of the "lastLogin" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.lastLogin
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "lastLogin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "lastLogin" field.
func (m *UserMutation) ClearLastLogin() {
	m.lastLogin = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "lastLogin" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "lastLogin" field.
func (m *UserMutation) ResetLastLogin() {
	m.lastLogin = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// AddReportedIDs adds the "reported" edge to the Report entity by ids.
func (m *UserMutation) AddReportedIDs(ids ...int) {
	if m.reported == nil {
		m.reported = make(map[int]struct{})
	}
	for i := range ids {
		m.reported[ids[i]] = struct{}{}
	}
}

// ClearReported clears the "reported" edge to the Report entity.
func (m *UserMutation) ClearReported() {
	m.clearedreported = true
}

// ReportedCleared reports if the "reported" edge to the Report entity was cleared.
func (m *UserMutation) ReportedCleared() bool {
	return m.clearedreported
}

// RemoveReportedIDs removes the "reported" edge to the Report entity by IDs.
func (m *UserMutation) RemoveReportedIDs(ids ...int) {
	if m.removedreported == nil {
		m.removedreported = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reported, ids[i])
		m.removedreported[ids[i]] = struct{}{}
	}
}

// RemovedReported returns the removed IDs of the "reported" edge to the Report entity.
func (m *UserMutation) RemovedReportedIDs() (ids []int) {
	for id := range m.removedreported {
		ids = append(ids, id)
	}
	return
}

// ReportedIDs returns the "reported" edge IDs in the mutation.
func (m *UserMutation) ReportedIDs() (ids []int) {
	for id := range m.reported {
		ids = append(ids, id)
	}
	return
}

// ResetReported resets all changes to the "reported" edge.
func (m *UserMutation) ResetReported() {
	m.reported = nil
	m.clearedreported = false
	m.removedreported = nil
}

// AddReporterIDs adds the "reporter" edge to the Report entity by ids.
func (m *UserMutation) AddReporterIDs(ids ...int) {
	if m.reporter == nil {
		m.reporter = make(map[int]struct{})
	}
	for i := range ids {
		m.reporter[ids[i]] = struct{}{}
	}
}

// ClearReporter clears the "reporter" edge to the Report entity.
func (m *UserMutation) ClearReporter() {
	m.clearedreporter = true
}

// ReporterCleared reports if the "reporter" edge to the Report entity was cleared.
func (m *UserMutation) ReporterCleared() bool {
	return m.clearedreporter
}

// RemoveReporterIDs removes the "reporter" edge to the Report entity by IDs.
func (m *UserMutation) RemoveReporterIDs(ids ...int) {
	if m.removedreporter == nil {
		m.removedreporter = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reporter, ids[i])
		m.removedreporter[ids[i]] = struct{}{}
	}
}

// RemovedReporter returns the removed IDs of the "reporter" edge to the Report entity.
func (m *UserMutation) RemovedReporterIDs() (ids []int) {
	for id := range m.removedreporter {
		ids = append(ids, id)
	}
	return
}

// ReporterIDs returns the "reporter" edge IDs in the mutation.
func (m *UserMutation) ReporterIDs() (ids []int) {
	for id := range m.reporter {
		ids = append(ids, id)
	}
	return
}

// ResetReporter resets all changes to the "reporter" edge.
func (m *UserMutation) ResetReporter() {
	m.reporter = nil
	m.clearedreporter = false
	m.removedreporter = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.ssoIdentifier != nil {
		fields = append(fields, user.FieldSsoIdentifier)
	}
	if m.vCardURL != nil {
		fields = append(fields, user.FieldVCardURL)
	}
	if m.permissions != nil {
		fields = append(fields, user.FieldPermissions)
	}
	if m.tags != nil {
		fields = append(fields, user.FieldTags)
	}
	if m.lastLogin != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUUID:
		return m.UUID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldSsoIdentifier:
		return m.SsoIdentifier()
	case user.FieldVCardURL:
		return m.VCardURL()
	case user.FieldPermissions:
		return m.Permissions()
	case user.FieldTags:
		return m.Tags()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldSsoIdentifier:
		return m.OldSsoIdentifier(ctx)
	case user.FieldVCardURL:
		return m.OldVCardURL(ctx)
	case user.FieldPermissions:
		return m.OldPermissions(ctx)
	case user.FieldTags:
		return m.OldTags(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldSsoIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSsoIdentifier(v)
		return nil
	case user.FieldVCardURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVCardURL(v)
		return nil
	case user.FieldPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case user.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldSsoIdentifier) {
		fields = append(fields, user.FieldSsoIdentifier)
	}
	if m.FieldCleared(user.FieldVCardURL) {
		fields = append(fields, user.FieldVCardURL)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldSsoIdentifier:
		m.ClearSsoIdentifier()
		return nil
	case user.FieldVCardURL:
		m.ClearVCardURL()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldSsoIdentifier:
		m.ResetSsoIdentifier()
		return nil
	case user.FieldVCardURL:
		m.ResetVCardURL()
		return nil
	case user.FieldPermissions:
		m.ResetPermissions()
		return nil
	case user.FieldTags:
		m.ResetTags()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.reported != nil {
		edges = append(edges, user.EdgeReported)
	}
	if m.reporter != nil {
		edges = append(edges, user.EdgeReporter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeReported:
		ids := make([]ent.Value, 0, len(m.reported))
		for id := range m.reported {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReporter:
		ids := make([]ent.Value, 0, len(m.reporter))
		for id := range m.reporter {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedreported != nil {
		edges = append(edges, user.EdgeReported)
	}
	if m.removedreporter != nil {
		edges = append(edges, user.EdgeReporter)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeReported:
		ids := make([]ent.Value, 0, len(m.removedreported))
		for id := range m.removedreported {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReporter:
		ids := make([]ent.Value, 0, len(m.removedreporter))
		for id := range m.removedreporter {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreported {
		edges = append(edges, user.EdgeReported)
	}
	if m.clearedreporter {
		edges = append(edges, user.EdgeReporter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeReported:
		return m.clearedreported
	case user.EdgeReporter:
		return m.clearedreporter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeReported:
		m.ResetReported()
		return nil
	case user.EdgeReporter:
		m.ResetReporter()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
